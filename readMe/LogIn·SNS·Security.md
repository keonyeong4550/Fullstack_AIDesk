## 팀장 김민식 

## 🧑‍💻 담당한 기능 요약

- **로그인 및 회원가입**
   
    JWT를 이용한 보안 처리 및 백엔드 Spring Security 사용하여 구현
    
- **소셜 로그인 통합**
    
    카카오 로그인을 JWT 기반 인증으로 통합하고 관리자 승인 정책을 동일하게 적용
    
- **얼굴 인식 로그인**
    
    임베딩 벡터 기반 얼굴 인식 로그인 구현 및 MariaDB + PostgreSQL DB 분리 설계
    
- **Refresh Token Rotation (RTR)**
    
    Redis를 이용한 Refresh Token Rotation 정책 구현 및 화이트리스트 기반 안전한 토큰 재발급
    
- **로그인 실패 계정 잠금**
    
    Redis를 이용한 일정 횟수 이상 로그인 실패 시 해당 계정이 일정 시간 로그인이 잠기는 기능 구현
    
- **관리자 페이지**
    
    승인 처리, 삭제 처리, 검색 및 필터 처리, 페이징 처리 기능 구현
    
- **업무 관리 시스템**
    
    업무 요청서 목록, 필터링, 중요업무(Pin) 기능 구현
    
- **파일 관리 시스템**
    
    파일 업로드/다운로드, 파일함 기능 구현
    
- **메인 대시보드**
    
    중요 업무, 읽지 않은 업무 등 사용자 정보 통합 대시보드 구현
    
- **전역 상태 관리**
    
    Redux Toolkit을 활용한 중요업무(Pin) 전역 상태 관리 및 사용자별 동기화
    

---

## 🚀 주요 기능

1. JWT 기반 로그인 및 사용자 인증
2. 소셜 로그인 연동
3. 관리자 페이지 구현
4. 업무 관리 시스템 개발
5. 파일 업로드 / 다운로드 기능
6. 사용자 중심 메인 대시보드
7. 전역 상태 관리 적용

---

## 👥 구현 기능 & 역할

| 구현 기능 | Front-End 담당 | Back-End 담당 | 설계 및 특징 |
| --- | --- | --- | --- |
| **로그인 및 회원가입** | • 소셜 로그인 API 연동 및 일반 회원가입 처리• JWT 토큰을 쿠키에 저장하여 보안성과 사용자 편의성 향상• Access Token 자동 재발급 로직 구현 (Subscriber 패턴) | • JWT 토큰 생성 및 Spring Security 보안 설정• 데이터베이스 및 서버 통신 보안 강화• Refresh Token Rotation (RTR) 정책 구현 | • JWT 토큰을 Authorization 헤더에 포함하여 로그인 필수 페이지 인증 검증• Access Token 유효기간이 임계값 이하일 경우 Refresh Token을 통한 Access Token 재발급 |
| **소셜 로그인 통합** | • 카카오 로그인 API 연동• 소셜 로그인 사용자 부서 정보 입력 유도• 승인 대기 상태 안내 메시지 표시 | • 카카오 API 호출 및 사용자 정보 조회• 소셜 회원 자동 생성• 일반 로그인과 동일한 JWT 토큰 발급 프로세스 적용 | • 카카오 로그인도 JWT 기반 인증 구조로 통합• 일반 로그인과 동일한 관리자 승인 프로세스 적용• 최초 가입 시 부서 정보 입력 유도 |
| **얼굴 인식 로그인** | • 웹캠을 통한 얼굴 촬영 UI• 얼굴 인식 설정 페이지 구현 | • Python AI 서버 연동 (WebClient)• 얼굴 임베딩 벡터 추출• PostgreSQL 벡터 검색 (pgvector)• Spring Security Authentication Filter 통합 | • 단순 이미지 비교가 아닌 임베딩 벡터 기반 인증• MariaDB(일반 데이터) + PostgreSQL(벡터 데이터) DB 분리 설계• L2 거리 기반 유사도 검색으로 사용자 식별 |
| **업무 관리 시스템** | • 업무 현황 리스트 (전체/받은/보낸)• 검색 및 필터 기능• 중요업무(Pin) 토글 기능• 페이지네이션 처리 | • 업무(Ticket) 목록 조회 API• 동적 쿼리 기반 검색 및 필터링• 중요업무(Pin) 관리 API• 읽음/안읽음 상태 관리 | • 업무 요청서 작성 시 파일 첨부 가능• 중요도, 마감일 기준 필터링• 서버 기준 읽음/안읽음 상태 관리• Redux를 통한 중요업무 전역 상태 관리 |
| **파일 관리 시스템** | • 파일 업로드 UI (이미지 미리보기)• 파일함 페이지 (전체/발신/수신)• 파일 다운로드 및 삭제 기능 | • 파일 업로드/다운로드 API• UUID 기반 파일명 저장• 파일 삭제 시 DB 및 파일 시스템 동기화 | • 이미지 파일은 미리보기 제공• Blob 형태로 파일 다운로드 처리• 파일명 인코딩 처리 (한글 파일명 지원) |
| **메인 대시보드** | • 중요 업무 개수 표시• 읽지 않은 업무 개수 표시• 최근 받은 업무 3건 표시• 최근 공지사항 3건 표시 | • 사용자별 통계 데이터 조회 API• 읽지 않은 업무 개수 조회 API• 최근 업무/공지 조회 API | • 실시간 데이터 동기화• 클릭 시 해당 페이지로 이동 및 필터링• 중요업무 슬라이드 Drawer 연동 |
| **전역 상태 관리 (Pin)** | • Redux Toolkit을 활용한 Pin 상태 관리• useCustomPin 커스텀 훅 구현• 로그아웃 시 상태 초기화• 사용자 변경 시 자동 동기화 | • Pin 토글 API• 사용자별 Pin 목록 조회 API | • 전역 상태로 모든 페이지에서 접근 가능• 사용자 단위로 Pin 목록 분리 관리• 로그인 사용자 변경 시 자동으로 해당 사용자 Pin 목록 로드 |
| **Refresh Token Rotation (RTR)** | • Access Token 만료 시 자동 재발급 요청• Subscriber 패턴을 통한 동시 요청 처리• 화이트리스트 기반 안전한 토큰 재발급 | • Refresh Token 회전 로직 구현• Redis 기반 Refresh Token 저장 및 관리• Token Family 개념을 통한 세션 관리• Replay 공격 방지 및 used 플래그 관리 | • Refresh Token은 1회성 사용 원칙 (RTR 정책)• 동시 요청 시 Race Condition 방지 (Subscriber 패턴)• Token Family 단위로 세션 무효화 가능 |
| **로그인 실패 계정 잠금** | • 로그인 실패 횟수 안내 메시지• 계정 잠금 시 남은 시간 표시• 잠금 상태 안내 | • Redis를 이용한 실패 횟수 관리• 5회 실패 시 30분 자동 잠금• TTL 기반 자동 잠금 해제• 로그인 성공 시 실패 횟수 초기화 | • Redis TTL을 활용한 자동 잠금 해제• 실패 횟수 실시간 추적 및 관리• 잠금 상태 조회 및 남은 시간 계산• 보안 강화를 위한 자동 계정 보호 |
| **관리자 페이지** | • 승인 대기 사용자 목록 표시• 전체 직원 목록 표시• 검색 및 필터 UI• 승인/삭제 버튼• 페이지네이션 UI | • 승인 대기 사용자 조회 API• 전체 직원 조회 API• 사용자 승인 처리 API• 사용자 삭제 처리 API (Soft Delete)• 검색 및 필터 로직• 페이지네이션 처리 | • 관리자 권한 기반 접근 제어• 이메일, 부서 기준 검색 및 필터링• 승인/삭제 처리 시 DB 상태 변경• 페이징을 통한 대량 데이터 효율적 관리 |


<br><br>
## 🛡️ 고도화된 JWT 인증 & Redis 세션 보안 아키텍처

### 1. 기술적 요약 (Core Identity)

> "NIST SP 800-63B 및 OWASP 가이드라인을 준수하여 최소 길이 중심의 패스워드 정책을 수립하고, Redis 화이트리스트 기반의 RTR(Refresh Token Rotation) 구조를 통해 분산 환경에서도 실시간 위협 탐지가 가능한 고성능 인증 시스템을 구현했습니다."
> 

---

### 2. 상세 보안 로직 및 설계 (Deep Dive)

**① 화이트리스트 기반의 '서버 기억형' 세션 관리**

- **화이트리스트 검증:** JWT의 한계인 '제어권 상실'을 보완하기 위해, 발급된 유효 Refresh Token을 Redis에서 **화이트리스트**로 관리합니다. 서버는 서명 유효성뿐만 아니라 "서버가 현재 승인한 토큰인가?"를 대조하여 즉각적인 세션 무효화를 수행합니다.
- **Token Family & 기기 격리:** `family_id` 클레임을 도입해 사용자 ID가 아닌 '로그인 세션 그룹' 단위로 관리합니다. 이를 통해 다중 기기 접속 환경에서 **특정 기기의 의심 세션만 정밀 타격하여 차단**함으로써 정상 사용자의 UX를 보호합니다.
- **Context Binding:** 토큰에 `User-Agent Hash`와 `IP 힌트`를 결합하여, 화이트리스트에 있더라도 접속 환경이 급격히 변할 경우 즉시 검증을 요청합니다.

**② RTR(Refresh Token Rotation) 및 재사용 감지 (Replay Detection)**

- **일회성 토큰 원칙:** 토큰 재발급 시마다 새로운 Refresh Token을 발행하여 탈취된 토큰의 생명주기를 극도로 단축했습니다.
- **실시간 재사용 탐지:** 이미 사용된(폐기된) 토큰이 유입되면 이를 **Replay Attack**으로 즉시 판단합니다. 이 경우 해당 토큰만 막는 것이 아니라, 관련된 **Token Family 전체를 화이트리스트에서 삭제**하여 잠재적 피해를 차단합니다.

**③ 인프라 성능 및 운영 최적화**

- **무상태(Stateless) 확장성:** 공유 저장소인 Redis를 활용하여 서버 증설(Scale-out) 시에도 세션 불일치 문제 없이 안정적인 인증 서비스를 유지합니다.
- **TTL 기반 자동 관리:** 로그인 실패 기록 및 만료 세션 정보를 Redis의 **TTL(Time-To-Live)** 기능을 통해 관리합니다. 별도의 DB 배치 작업 없이도 데이터가 자동 정리되어 메모리 누수를 방지하고 운영 부담을 줄였습니다.
- **성능 고도화:** Redis **Connection Pool** 활성화 및 **Pipelining(배치 명령)**을 활용해 네트워크 왕복 시간을 최소화했으며, RDBMS 대비 인증 처리 속도를 획기적으로 개선했습니다.

**④ 보안 위협 선제적 대응**

- **Brute-force 방어:** Redis의 `Atomic Increment`를 활용해 로그인 5회 실패 시 30분을 자동 차단합니다. 차단 상태에서 재시도 시 남은 제한 시간을 실시간으로 반환하여 사용자 가이드를 제공합니다.
- **토큰 혼용 공격 방지:** `tokenType` 클레임을 명시하여 Access/Refresh 토큰이 본래 용도와 다르게 사용되는 것을 원천 차단했습니다.
- **XSS 및 CSRF 대응:** Refresh Token은 브라우저 JS가 접근할 수 없는 `HttpOnly`, `Secure`, `SameSite` 쿠키로만 전달하여 토큰 탈취 가능성을 최소화했습니다.

---

### 3. 글로벌 보안 표준 준수 (Standard Alignment)

- **NIST SP 800-63B 준수:** 사용자 경험을 저해하는 과도한 특수문자 조합 강요 대신, **충분한 최소 길이(8자 이상)** 확보와 FE/BE 이중 유효성 검증을 통해 실질적인 보안성을 강화했습니다.
- **OWASP ASVS 대응:** 전송 계층 보안뿐만 아니라 세션 관리(Session Management) 항목의 권고사항인 '강력한 세션 파기' 및 '기기 컨텍스트 검증'을 아키텍처 레벨에서 구현했습니다.

---

### 🚀 프로젝트의 기술적 차별점 (최종 정리)

1. **정밀한 세션 통제:** Token Family 전략으로 전체 로그아웃 없이 위협 기기만 선택적 차단 가능.
2. **능동적 공격 대응:** RTR과 화이트리스트를 결합하여 토큰 탈취 시도를 실시간으로 탐지하고 즉각 무효화.
3. **고성능·저비용 운영:** Redis 특성을 100% 활용하여 성능과 운영 편의성(자동 삭제 등)을 동시에 확보.

---
# 플로우 차트
### 회원가입
![Image](https://github.com/user-attachments/assets/6410cddb-48ba-4236-8925-0eeccee98953)
### 로그인 & 로그아웃
![Image](https://github.com/user-attachments/assets/567e6350-8457-4345-b443-bb4244ae3c55)
### 소셜 로그인
![Image](https://github.com/user-attachments/assets/a29963b8-a089-4703-90f4-fbd1cede31ed)
### 얼굴 등록(임베딩)
![Image](https://github.com/user-attachments/assets/c2dd5971-4b74-4074-adaa-46dbab1598b2)
### 얼굴 로그인(임베딩)
![Image](https://github.com/user-attachments/assets/f5c795e2-23be-489d-9bb0-7bd0c5ee395f)
### 관리자 페이지
![Image](https://github.com/user-attachments/assets/f6d31268-7d0e-4170-bba5-4ef5ac29f670)
### 중요업무(장바구니)
![Image](https://github.com/user-attachments/assets/eea72182-d64d-4179-885f-e1e2868c8f87)
### 파일함
![Image](https://github.com/user-attachments/assets/49170c92-c9a7-48c9-bbc9-dbe1e1eef525)
### 메인페이지
![Image](https://github.com/user-attachments/assets/5947590c-473a-4a0d-a734-6b4f858fdef6)
---


# 트러블 슈팅

### 1️⃣ Refresh Token 쿠키가 변경되지 않는 문제

**문제 현상**

Refresh Token이 재발급되었지만 브라우저에 반영되지 않고, 브라우저가 계속 예전 Refresh Token을 전송하여 `REFRESH_REPLAY_DETECTED` 에러가 발생했습니다.

**원인 분석**

- 로컬 개발 환경(HTTP)에서 `Secure=true`와 `SameSite=None` 조합을 사용하여 브라우저가 쿠키를 거부했습니다.
- `response.addCookie()`와 `response.addHeader("Set-Cookie")`를 혼용하여 중복된 Set-Cookie 헤더가 생성되었습니다.

**해결 방법**

- 환경에 따른 동적 쿠키 설정: `request.isSecure()`로 환경을 감지하여 로컬 환경에서는 `Secure=false`, `SameSite=Lax`를 사용하고, 프로덕션 환경에서는 `Secure=true`, `SameSite=None`을 사용합니다.
- `ResponseCookie` 단일 사용: `response.addCookie()`를 제거하고 `response.addHeader("Set-Cookie", ...)`만 사용하여 일관성을 보장합니다.

**결과**

로컬 개발 환경과 프로덕션 환경 모두에서 Refresh Token이 브라우저에 올바르게 반영되었습니다.

---

### 2️⃣ Access Token 재발급 Race Condition 문제

**문제 현상**

Refresh Token을 이용한 Access Token 재발급이 일부 요청에서만 성공하고, 동시 요청 시 `REFRESH_REPLAY_DETECTED` 에러가 발생했습니다.

**원인 분석**

- JWT RTR 정책 적용으로 Refresh Token 사용 시마다 기존 토큰이 무효화됩니다.
- 프론트엔드 비동기 동시 요청과 충돌하여 Race Condition이 발생했습니다.
- Axios 인터셉터 내 `_retry` 플래그 설정 오류 및 변수 선언 문제가 있었습니다.

**해결 방법 — Subscriber 패턴 + 요청 대기열(Queue) 적용**

- `isRefreshing` 플래그로 토큰 갱신 중 다른 요청을 차단합니다.
- 대기열(`refreshSubscribers`)에 모든 추가 요청을 저장합니다.
- 첫 번째 요청 완료 시 새 토큰을 대기열 요청에 전달 후 재실행합니다.
- `_retry` 체크를 최상단으로 이동하여 무한 루프를 방지합니다.

**결과**

- 네트워크 효율성 증가: Refresh API 호출이 1회로 감소했습니다.
- 서버 RTR 정책 준수 및 `REFRESH_REPLAY_DETECTED` 에러 해결
- 사용자 경험 향상: 토큰 만료 시에도 흐름 끊김 없이 처리됩니다.

---

### 3️⃣ 관리자 페이지 인증 오류

**문제 현상**

관리자 페이지에서 인증 오류가 발생하여 접근이 불가능했습니다.

**원인 분석**

- `getClaims()`에서 비밀번호 반환을 제거했지만, `UsernamePasswordAuthenticationToken`에는 여전히 비밀번호가 필요했습니다.
- 비밀번호를 `null`로 처리하면 인증 오류가 발생했습니다.

**해결 방법**

- 임의 문자열 `"PROTECTED"`를 지정하여 인증 토큰을 생성하도록 수정했습니다.
- DTO와 인증 토큰 간 비밀번호 불일치 문제를 해결했습니다.

**결과**

관리자 페이지 접근 및 권한 로직이 정상 동작합니다.

---

### 4️⃣ 동적 쿼리 변환 이후 도메인 데이터 타입 문제

**문제 현상**

동적 쿼리 변환 이후 도메인 입력 타입과 동적 쿼리 구조가 불일치하여 에러가 발생했습니다.

**원인 분석**

- 기존 도메인 입력 타입과 동적 쿼리 구조가 맞지 않았습니다.

**해결 방법**

- 도메인 입력 타입을 변경하여 문제를 해결했습니다.

---

### 5️⃣ JWT 토큰 에러 (Pageable Sort)

**문제 현상**

`Pageable`의 `Sort.by("email").descending()` 사용 시 `JwtCheckFilter`에서 에러가 발생했습니다.

**원인 분석**

- Spring Data JPA가 `member.email` 형태의 JPQL 경로를 생성했습니다.
- `member`가 JPQL 예약어이거나 실제 쿼리 Alias와 일치하지 않아 오류가 발생했습니다.

**해결 방법**

- 해당 동적 정렬 로직을 제거하고 정적 정렬 방식으로 대체하여 적용했습니다.

---

### 6️⃣ 필터 및 정렬 파라미터 처리 오류

**문제 현상**

마감순 정렬 관련 필터가 `filterParam`(검색 포함) 쪽으로 전달되고 있었습니다.

**해결 방법**

- 정렬 관련 파라미터를 `pageParam`(정렬 포함) 쪽으로 분리하여 전송하도록 수정했습니다.
- 필터 + 정렬 로직이 정상적으로 동작하는 것을 확인했습니다.

---

### 7️⃣ 업무 현황 페이지 필터 처리 로직 오류

**문제 현상**

업무 현황 페이지의 필터 처리 로직을 전면 수정하는 과정에서 쿼리문 내 타입 불일치 및 함수 사용 오류가 발생했습니다.

**해결 방법**

- 필터 처리 관련 쿼리 로직을 하나씩 추적하여 문제 지점을 파악했습니다.
- 잘못된 타입 및 함수 사용 부분을 수정하여 정상 동작을 확인했습니다.

---

### 8️⃣ 파일 업로드 / 전송 오류

**문제 현상**

파일이 정상적으로 전달되지 않는 문제가 발생했습니다.

**해결 방법**

- Blob으로 감싸서 전송하도록 수정하여 정상 동작을 확인했습니다.

---

### 9️⃣ 이미지 및 파일 다운로드 인증 문제

**문제 현상**

`JwtCheckFilter`에서 이미지 조회 및 다운로드 요청도 토큰 검사로 막히는 문제가 발생했습니다.

**해결 방법**

- 이미지 조회 및 다운로드 로직은 토큰 검사 예외 처리하여 정상적으로 파일 로딩이 가능하도록 수정했습니다.

---

### 🔟 받은 티켓에서 파일이 보이지 않는 문제

**문제 현상**

받은 티켓(Read 화면)에서 파일이 보이지 않았습니다.

**원인 분석**

- 파일 조회용 DTO에 `file` 필드가 포함되지 않았습니다.

**해결 방법**

- DTO에 파일 정보를 추가하여 정상적으로 조회 가능하도록 수정했습니다.

---

### 1️⃣1️⃣ 티켓 삭제 시 파일이 남아있는 문제

**문제 현상**

티켓 삭제 시 DB에서는 파일이 삭제되지만 실제 파일이 남아있었습니다.

**원인 분석**

- JPA `cascade` 설정으로 DB 레코드는 삭제되지만, 실제 파일 시스템에서 파일을 삭제하는 로직이 존재하지 않았습니다.

**해결 방법**

- 티켓 삭제 로직에 실제 파일 삭제 처리 로직을 추가하여 동기화했습니다.

---

### 1️⃣2️⃣ AI 비서 메시지 권한 체크 오류

**문제 현상**

`main` 코드에서 `JwtCheckFilter`가 `api/ai` 로직을 우회하여 AI 비서 측에서 메시지 처리 시 권한 체크 에러가 발생했습니다.

**해결 방법**

- AI API 경로에 대한 권한 체크 로직을 수정했습니다.

---

### 1️⃣3️⃣ 회의록 파일 처리 오류

**문제 현상**

파일 전송 시 처리 오류가 발생했습니다.

**해결 방법**

- 파일 전송 시 Blob으로 감싸고, 컨트롤러에서는 `RequestParam` 대신 `RequestPart`로 처리하도록 수정했습니다.
- Axios 호출 시 header에 `access token`이 포함되더라도 param 처리 오류를 방지했습니다.

---

### 1️⃣4️⃣ 회원가입 중복 이메일 처리 오류

**문제 현상**

중복 이메일 가입 시 에러는 발생하지만 Front에 제대로 전달되지 않았습니다.

**해결 방법**

- 별도 예외 정의 및 핸들러 등록을 통해 Front에 적절한 alert 메시지가 표시되도록 개선했습니다.


---
